package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/iprotoresume/gateway-go/graph/model"
	pb "github.com/iprotoresume/shared/proto"
)

// TailorResume is the resolver for the tailorResume field.
// TailorResume is the resolver for the tailorResume field.
func (r *mutationResolver) TailorResume(ctx context.Context, input model.TailorResumeInput) (*model.TailorResponse, error) {
	req := &pb.TailorRequest{
		OriginalResume: &pb.ResumeData{
			FullName:     input.OriginalResume.FullName,
			Email:        input.OriginalResume.Email,
			Phone:        getStringValue(input.OriginalResume.Phone),
			Summary:      getStringValue(input.OriginalResume.Summary),
			Skills:       input.OriginalResume.Skills,
			JobTitle:     getStringValue(input.OriginalResume.JobTitle),
			Location:     getStringValue(input.OriginalResume.Location),
			Linkedin:     getStringValue(input.OriginalResume.Linkedin),
			Github:       getStringValue(input.OriginalResume.Github),
			Website:      getStringValue(input.OriginalResume.Website),
			Experience:   mapExperienceInput(input.OriginalResume.Experience),
			Education:    mapEducationInput(input.OriginalResume.Education),
			Projects:     mapProjectInput(input.OriginalResume.Projects),
			Certificates: mapCertificateInput(input.OriginalResume.Certificates),
			SkillGroups:  mapSkillGroupInput(input.OriginalResume.SkillGroups),
			Languages:    mapLanguageInput(input.OriginalResume.Languages),
			Achievements: mapAchievementInput(input.OriginalResume.Achievements),
		},
		JobDescription: input.JobDescription,
	}

	resp, err := r.AIClient.Client.TailorResume(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to tailor resume: %w", err)
	}

	return &model.TailorResponse{
		TailoredResume: mapProtoResumeToModel(resp.TailoredResume),
		CoverLetter:    &resp.CoverLetter,
	}, nil
}

// ValidateResume is the resolver for the validateResume field.
func (r *mutationResolver) ValidateResume(ctx context.Context, input model.ValidateResumeInput) (*model.ATSScore, error) {
	req := &pb.AnalyzeResumeRequest{
		Resume: &pb.ResumeData{
			FullName:     input.Resume.FullName,
			Email:        input.Resume.Email,
			Phone:        getStringValue(input.Resume.Phone),
			Summary:      getStringValue(input.Resume.Summary),
			Skills:       input.Resume.Skills,
			Experience:   mapExperienceInput(input.Resume.Experience),
			Education:    mapEducationInput(input.Resume.Education),
			Projects:     mapProjectInput(input.Resume.Projects),
			Certificates: mapCertificateInput(input.Resume.Certificates),
			JobTitle:     getStringValue(input.Resume.JobTitle),
			Location:     getStringValue(input.Resume.Location),
			Linkedin:     getStringValue(input.Resume.Linkedin),
			Github:       getStringValue(input.Resume.Github),
			Website:      getStringValue(input.Resume.Website),
			ProfileImage: getStringValue(input.Resume.ProfileImage),
			SkillGroups:  mapSkillGroupInput(input.Resume.SkillGroups),
			Languages:    mapLanguageInput(input.Resume.Languages),
			Achievements: mapAchievementInput(input.Resume.Achievements),
		},
		JobDescription: input.JobDescription,
	}

	resp, err := r.AIClient.Client.AnalyzeResume(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to validate resume: %w", err)
	}

	return &model.ATSScore{
		Score:           resp.Score,
		Feedback:        resp.Feedback,
		MissingKeywords: resp.MissingKeywords,
		Reasoning:       &resp.Reasoning,
	}, nil
}

// SaveResume is the resolver for the saveResume field.
func (r *mutationResolver) SaveResume(ctx context.Context, input model.SaveResumeInput) (*model.SavedResume, error) {
	req := &pb.SaveResumeRequest{
		Resume: &pb.ResumeData{
			FullName:     input.Resume.FullName,
			Email:        input.Resume.Email,
			Phone:        getStringValue(input.Resume.Phone),
			Summary:      getStringValue(input.Resume.Summary),
			Skills:       input.Resume.Skills,
			Experience:   mapExperienceInput(input.Resume.Experience),
			Education:    mapEducationInput(input.Resume.Education),
			Projects:     mapProjectInput(input.Resume.Projects),
			Certificates: mapCertificateInput(input.Resume.Certificates),
			JobTitle:     getStringValue(input.Resume.JobTitle),
			Location:     getStringValue(input.Resume.Location),
			Linkedin:     getStringValue(input.Resume.Linkedin),
			Github:       getStringValue(input.Resume.Github),
			Website:      getStringValue(input.Resume.Website),
			ProfileImage: getStringValue(input.Resume.ProfileImage),
			SkillGroups:  mapSkillGroupInput(input.Resume.SkillGroups),
			Languages:    mapLanguageInput(input.Resume.Languages),
			Achievements: mapAchievementInput(input.Resume.Achievements),
		},
		Tags:    input.Tags,
		Version: input.Version,
	}

	resp, err := r.PersistenceClient.Client.SaveResume(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to save resume: %w", err)
	}

	return &model.SavedResume{
		ID:        resp.Id,
		Resume:    mapProtoResumeToModel(resp.ResumeData),
		Tags:      resp.Tags,
		Version:   resp.Version,
		CreatedAt: resp.CreatedAt,
	}, nil
}

// DeleteResume is the resolver for the deleteResume field.
func (r *mutationResolver) DeleteResume(ctx context.Context, id string) (bool, error) {
	req := &pb.DeleteResumeRequest{
		Id: id,
	}

	resp, err := r.PersistenceClient.Client.DeleteResume(ctx, req)
	if err != nil {
		return false, fmt.Errorf("failed to delete resume: %w", err)
	}

	return resp.Success, nil
}

// GenerateInterviewQuestions is the resolver for the generateInterviewQuestions field.
func (r *mutationResolver) GenerateInterviewQuestions(ctx context.Context, input model.InterviewPrepInput) (*model.QuestionsResponse, error) {
	req := &pb.InterviewPrepRequest{
		Resume: &pb.ResumeData{
			FullName:     input.Resume.FullName,
			Email:        input.Resume.Email,
			Phone:        getStringValue(input.Resume.Phone),
			Summary:      getStringValue(input.Resume.Summary),
			Skills:       input.Resume.Skills,
			Experience:   mapExperienceInput(input.Resume.Experience),
			Education:    mapEducationInput(input.Resume.Education),
			Projects:     mapProjectInput(input.Resume.Projects),
			Certificates: mapCertificateInput(input.Resume.Certificates),
			JobTitle:     getStringValue(input.Resume.JobTitle),
			Location:     getStringValue(input.Resume.Location),
			Linkedin:     getStringValue(input.Resume.Linkedin),
			Github:       getStringValue(input.Resume.Github),
			Website:      getStringValue(input.Resume.Website),
			ProfileImage: getStringValue(input.Resume.ProfileImage),
			SkillGroups:  mapSkillGroupInput(input.Resume.SkillGroups),
			Languages:    mapLanguageInput(input.Resume.Languages),
			Achievements: mapAchievementInput(input.Resume.Achievements),
		},
		JobDescription: input.JobDescription,
	}

	resp, err := r.AIClient.Client.GenerateInterviewQuestions(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to generate interview questions: %w", err)
	}

	var questions []*model.InterviewQuestion
	for _, q := range resp.Questions {
		questions = append(questions, &model.InterviewQuestion{
			Question:    q.Question,
			Type:        q.Type,
			AnswerGuide: stringPtr(q.AnswerGuide),
		})
	}

	return &model.QuestionsResponse{
		Questions: questions,
	}, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// ListResumes is the resolver for the listResumes field.
func (r *queryResolver) ListResumes(ctx context.Context, filter *model.ListResumesFilter) ([]*model.SavedResume, error) {
	req := &pb.ListResumesRequest{}
	if filter != nil {
		req.Tags = filter.Tags
	}

	resp, err := r.PersistenceClient.Client.ListResumes(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to list resumes: %w", err)
	}

	var results []*model.SavedResume
	for _, r := range resp.Resumes {
		results = append(results, &model.SavedResume{
			ID:        r.Id,
			Resume:    mapProtoResumeToModel(r.ResumeData),
			Tags:      r.Tags,
			Version:   r.Version,
			CreatedAt: r.CreatedAt,
		})
	}
	return results, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
