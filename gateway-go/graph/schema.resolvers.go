package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/iprotoresume/gateway-go/graph/model"
	pb "github.com/iprotoresume/shared/proto"
)

// TailorResume is the resolver for the tailorResume field.
// TailorResume is the resolver for the tailorResume field.
func (r *mutationResolver) TailorResume(ctx context.Context, input model.TailorResumeInput) (*model.TailorResponse, error) {
	req := &pb.TailorRequest{
		OriginalResume: &pb.ResumeData{
			FullName:     input.OriginalResume.FullName,
			Email:        input.OriginalResume.Email,
			Phone:        getStringValue(input.OriginalResume.Phone),
			Summary:      getStringValue(input.OriginalResume.Summary),
			Skills:       input.OriginalResume.Skills,
			JobTitle:     getStringValue(input.OriginalResume.JobTitle),
			Location:     getStringValue(input.OriginalResume.Location),
			Linkedin:     getStringValue(input.OriginalResume.Linkedin),
			Github:       getStringValue(input.OriginalResume.Github),
			Website:      getStringValue(input.OriginalResume.Website),
			Experience:   mapExperienceInput(input.OriginalResume.Experience),
			Education:    mapEducationInput(input.OriginalResume.Education),
			Projects:     mapProjectInput(input.OriginalResume.Projects),
			Certificates: mapCertificateInput(input.OriginalResume.Certificates),
			SkillGroups:  mapSkillGroupInput(input.OriginalResume.SkillGroups),
			Languages:    mapLanguageInput(input.OriginalResume.Languages),
			Achievements: mapAchievementInput(input.OriginalResume.Achievements),
		},
		JobDescription: input.JobDescription,
	}

	resp, err := r.AIClient.Client.TailorResume(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to tailor resume: %w", err)
	}

	return &model.TailorResponse{
		TailoredResume: mapProtoResumeToModel(resp.TailoredResume),
		CoverLetter:    &resp.CoverLetter,
	}, nil
}

// ValidateResume is the resolver for the validateResume field.
func (r *mutationResolver) ValidateResume(ctx context.Context, input model.ValidateResumeInput) (*model.ATSScore, error) {
	req := &pb.AnalyzeResumeRequest{
		Resume: &pb.ResumeData{
			FullName:     input.Resume.FullName,
			Email:        input.Resume.Email,
			Phone:        getStringValue(input.Resume.Phone),
			Summary:      getStringValue(input.Resume.Summary),
			Skills:       input.Resume.Skills,
			Experience:   mapExperienceInput(input.Resume.Experience),
			Education:    mapEducationInput(input.Resume.Education),
			Projects:     mapProjectInput(input.Resume.Projects),
			Certificates: mapCertificateInput(input.Resume.Certificates),
			JobTitle:     getStringValue(input.Resume.JobTitle),
			Location:     getStringValue(input.Resume.Location),
			Linkedin:     getStringValue(input.Resume.Linkedin),
			Github:       getStringValue(input.Resume.Github),
			Website:      getStringValue(input.Resume.Website),
			ProfileImage: getStringValue(input.Resume.ProfileImage),
			SkillGroups:  mapSkillGroupInput(input.Resume.SkillGroups),
			Languages:    mapLanguageInput(input.Resume.Languages),
			Achievements: mapAchievementInput(input.Resume.Achievements),
		},
		JobDescription: input.JobDescription,
	}

	resp, err := r.AIClient.Client.AnalyzeResume(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to validate resume: %w", err)
	}

	return &model.ATSScore{
		Score:           resp.Score,
		Feedback:        resp.Feedback,
		MissingKeywords: resp.MissingKeywords,
		Reasoning:       &resp.Reasoning,
	}, nil
}

// SaveResume is the resolver for the saveResume field.
func (r *mutationResolver) SaveResume(ctx context.Context, input model.SaveResumeInput) (*model.SavedResume, error) {
	req := &pb.SaveResumeRequest{
		Resume: &pb.ResumeData{
			FullName:     input.Resume.FullName,
			Email:        input.Resume.Email,
			Phone:        getStringValue(input.Resume.Phone),
			Summary:      getStringValue(input.Resume.Summary),
			Skills:       input.Resume.Skills,
			Experience:   mapExperienceInput(input.Resume.Experience),
			Education:    mapEducationInput(input.Resume.Education),
			Projects:     mapProjectInput(input.Resume.Projects),
			Certificates: mapCertificateInput(input.Resume.Certificates),
			JobTitle:     getStringValue(input.Resume.JobTitle),
			Location:     getStringValue(input.Resume.Location),
			Linkedin:     getStringValue(input.Resume.Linkedin),
			Github:       getStringValue(input.Resume.Github),
			Website:      getStringValue(input.Resume.Website),
			ProfileImage: getStringValue(input.Resume.ProfileImage),
			SkillGroups:  mapSkillGroupInput(input.Resume.SkillGroups),
			Languages:    mapLanguageInput(input.Resume.Languages),
			Achievements: mapAchievementInput(input.Resume.Achievements),
		},
		Tags:    input.Tags,
		Version: input.Version,
	}

	resp, err := r.PersistenceClient.Client.SaveResume(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to save resume: %w", err)
	}

	return &model.SavedResume{
		ID:        resp.Id,
		Resume:    mapProtoResumeToModel(resp.ResumeData),
		Tags:      resp.Tags,
		Version:   resp.Version,
		CreatedAt: resp.CreatedAt,
	}, nil
}

// DeleteResume is the resolver for the deleteResume field.
func (r *mutationResolver) DeleteResume(ctx context.Context, id string) (bool, error) {
	req := &pb.DeleteResumeRequest{
		Id: id,
	}

	resp, err := r.PersistenceClient.Client.DeleteResume(ctx, req)
	if err != nil {
		return false, fmt.Errorf("failed to delete resume: %w", err)
	}

	return resp.Success, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// ListResumes is the resolver for the listResumes field.
func (r *queryResolver) ListResumes(ctx context.Context, filter *model.ListResumesFilter) ([]*model.SavedResume, error) {
	req := &pb.ListResumesRequest{}
	if filter != nil {
		req.Tags = filter.Tags
	}

	resp, err := r.PersistenceClient.Client.ListResumes(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to list resumes: %w", err)
	}

	var results []*model.SavedResume
	for _, r := range resp.Resumes {
		results = append(results, &model.SavedResume{
			ID:        r.Id,
			Resume:    mapProtoResumeToModel(r.ResumeData),
			Tags:      r.Tags,
			Version:   r.Version,
			CreatedAt: r.CreatedAt,
		})
	}
	return results, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func mapExperienceInput(inputs []*model.ExperienceInput) []*pb.Experience {
	var results []*pb.Experience
	for _, in := range inputs {
		results = append(results, &pb.Experience{
			Title:       in.Title,
			Company:     in.Company,
			StartDate:   getStringValue(in.StartDate),
			EndDate:     getStringValue(in.EndDate),
			Description: getStringValue(in.Description),
		})
	}
	return results
}
func mapEducationInput(inputs []*model.EducationInput) []*pb.Education {
	var results []*pb.Education
	for _, in := range inputs {
		results = append(results, &pb.Education{
			Degree:         in.Degree,
			Institution:    in.Institution,
			GraduationDate: getStringValue(in.GraduationDate),
		})
	}
	return results
}
func mapProjectInput(inputs []*model.ProjectInput) []*pb.Project {
	var results []*pb.Project
	for _, in := range inputs {
		results = append(results, &pb.Project{
			Title:       in.Title,
			Description: in.Description,
			TechStack:   in.TechStack,
			Date:        getStringValue(in.Date),
			Location:    getStringValue(in.Location),
		})
	}
	return results
}
func mapCertificateInput(inputs []*model.CertificateInput) []*pb.Certificate {
	var results []*pb.Certificate
	for _, in := range inputs {
		results = append(results, &pb.Certificate{
			Name:   in.Name,
			Issuer: in.Issuer,
			Date:   getStringValue(in.Date),
			Link:   getStringValue(in.Link),
		})
	}
	return results
}
func mapSkillGroupInput(inputs []*model.SkillGroupInput) []*pb.SkillGroup {
	var results []*pb.SkillGroup
	for _, in := range inputs {
		results = append(results, &pb.SkillGroup{
			Category: in.Category,
			Items:    in.Items,
		})
	}
	return results
}
func mapLanguageInput(inputs []*model.LanguageInput) []*pb.Language {
	var results []*pb.Language
	for _, in := range inputs {
		results = append(results, &pb.Language{
			Language:    in.Language,
			Proficiency: in.Proficiency,
		})
	}
	return results
}
func mapAchievementInput(inputs []*model.AchievementInput) []*pb.Achievement {
	var results []*pb.Achievement
	for _, in := range inputs {
		results = append(results, &pb.Achievement{
			Title:       in.Title,
			Description: in.Description,
		})
	}
	return results
}
func mapProtoResumeToModel(p *pb.ResumeData) *model.ResumeData {
	if p == nil {
		return &model.ResumeData{}
	}

	// Map persistence-only fields back to model
	// (Projects and Certs logic similar to Experience)
	var projects []*model.Project
	for _, prj := range p.Projects {
		projects = append(projects, &model.Project{
			Title:       prj.Title,
			Description: prj.Description,
			TechStack:   prj.TechStack,
			Date:        &prj.Date,
			Location:    &prj.Location,
		})
	}

	var certs []*model.Certificate
	for _, cert := range p.Certificates {
		certs = append(certs, &model.Certificate{
			Name:   cert.Name,
			Issuer: cert.Issuer,
			Date:   &cert.Date,
			Link:   &cert.Link,
		})
	}

	var exp []*model.Experience
	for _, e := range p.Experience {
		exp = append(exp, &model.Experience{
			Title:       e.Title,
			Company:     e.Company,
			StartDate:   &e.StartDate,
			EndDate:     &e.EndDate,
			Description: &e.Description,
		})
	}

	var edu []*model.Education
	for _, e := range p.Education {
		edu = append(edu, &model.Education{
			Degree:         e.Degree,
			Institution:    e.Institution,
			GraduationDate: &e.GraduationDate,
		})
	}

	var skillGroups []*model.SkillGroup
	for _, sg := range p.SkillGroups {
		skillGroups = append(skillGroups, &model.SkillGroup{
			Category: sg.Category,
			Items:    sg.Items,
		})
	}

	var languages []*model.Language
	for _, lang := range p.Languages {
		languages = append(languages, &model.Language{
			Language:    lang.Language,
			Proficiency: lang.Proficiency,
		})
	}

	var achievements []*model.Achievement
	for _, ach := range p.Achievements {
		achievements = append(achievements, &model.Achievement{
			Title:       ach.Title,
			Description: ach.Description,
		})
	}

	return &model.ResumeData{
		FullName:     p.FullName,
		Email:        p.Email,
		Phone:        &p.Phone,
		Summary:      &p.Summary,
		Skills:       p.Skills,
		Experience:   exp,
		Education:    edu,
		Projects:     projects,
		Certificates: certs,
		JobTitle:     &p.JobTitle,
		Location:     &p.Location,
		Linkedin:     &p.Linkedin,
		Github:       &p.Github,
		Website:      &p.Website,
		ProfileImage: &p.ProfileImage,
		SkillGroups:  skillGroups,
		Languages:    languages,
		Achievements: achievements,
	}
}
func stringPtr(s string) *string {
	return &s
}
func getStringValue(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}
*/
